#include<stdio.h>
#include<stdlib.h>

// 任何一个结构都是属性集合+操作集合
// 属性集合在C语言中就是结构体，对于高级语言来说就是类

// 结点的属性集合(对应C语言中的结构体)：
typedef struct NodeList {
	// 一属性：
	// 1、存储具体的数据
	int element;

	// 二指针：指向下一个节点的指针
	struct NodeList* next;

	// 三还需要什么？根据实际需求来设计
	// 觉得头节点浪费空间？我们可以多定义一个属性：代表当前链表的元素个数
	// 这个属性只有头节点存在
	// int num;
}Node;


// 操作集合也就是一系列函数
// 增删改查、初始化链表
// 在链表还没有开始使用的时候或者说刚开始使用的时候要先初始化一个链表
// 尤其是如果想要写一个带头节点的链表的话，就要先初始化一个头节点出来，这就要用到初始化操作

// 初始化一个带头节点的单向链表
Node* InitList()
{
	// 首先，要生成一个结点
	Node* node = (Node*)malloc(sizeof(Node));

	// 按照规范，如果要做malloc的话就要判断一下它是否malloc分配成功
	if (node == NULL)
	{
		// 如果node == NULL就表示分配不成功
	}
	else
	{
		// node != NULL表示分配成功
		// 接下来就是具体的初始化操作
		// 对于int型数据element而言，这个初始化操作无所谓
		// 对于指针而言，我们需要把指针初始为NULL
		node->next = NULL;
		// 至此头节点就做好了，最后将头节点返回即可
	}
	return node;//返回头节点
}

// 增删改查
// 添加元素
// 有很多中添加元素的方式，这里写一个头插
// 继续分析，添加一个元素，需要什么东西？
// 元素的首先必须知道添加的具体数值int key
// 第二个，我要往哪一个链表里面添加？——Node* node
// node表示要插入的链表是哪一个链表
void head_insert(int key, Node* node)
{
	//1、先建立一个结点
	Node* tmp = (Node*)malloc(sizeof(Node)); // 生成一个结点

	// 将新节点的指针指向头节点的下一个元素
	// 因为是头插，所以新节点的指针指向的元素就是头节点的指针指向的元素
	tmp->next = node->next; 
	// 然后再把头节点的下一个结点改掉
	node->next = tmp;
	// 最后用key初始化tmp的element
	tmp->element = key; 
}

// 中间插入和头插差不多，这里自己尝试书写

// 查询
// 也需要两个参数
int find(int key, Node* node)
{
	// 首先还是要定义一个指针，这个指针要指向头节点或者说是头节点的下一个结点,从第一个元素开始
	// 为什么？
	// 因为头指针在任何情况下都不能动，就像写程序的main函数一样，其它的可以动，main函数
	// 只能叫main函数且不能改动，要是把main给改了，程序就找不到入口，那么就不能正常执行程序
	// 这里也可以类比数组的数组名是一个指针，这个指针不能动，其实和这里差不多
	// 不能动的原因就是，数组名这个指针是结合数组下标索引用来定位数组中的元素的
	// 要是动了，就不能通过索引去找元素了
	// 既然头指针不能动，又要遍历链表，就要建立一个新的变量
	// 即建立一个新的临时指针变量，让它指向头节点
	// 的因为我们的链表是带头节点的单链表，所以我们直接指向头节点next就好了，也就是直接指向第一个元素
	// 从链表中第一个元素开始遍历
	Node* tmp = node->next;// 指向第一个元素

	// 从第一个元素开始，不断的往下找
	// 我们要找的是一个下标，所以还需要定义一个变量来存储下标
	int i = 0; // 这里规定下标从0开始
	// 接下来就一直找
	while (tmp != NULL)
	{
		if (tmp->element == key)
		{
			return i; // 如果找到了，返回下标
		}
		i++; // 如果还没找到，下标++并且移动指针
		tmp = tmp->next; // 移动指针
	}

	return -1; // 没找到
}

// 删除结点
// 这里的实现没看明白，一定要弄清楚
// 也是一样的分析，我要删除什么样的数据以及我要在哪一个链表把这个数据删掉
void delete_node(int key, Node* node)
{
	// 如果说要执行删除操作，第一步是什么?
	// 先看看有没有这个元素，所以说删除操作都会伴随着查询
	// 查询
	// 首先要接收find函数返回的值，看看有没有这个元素
	// 严谨来说，还是要先判断参数
	// 先判断链表是否为空
	if (node == NULL)
	{
		// 告诉使用者，这是一个空链表，没办法删了，请先初始化
	}
	int index = find(key, node);
	if (index == -1)
	{
		// 没有这个元素
	}
	else
	{
		// 既不是空也不是-1那么就可以开始执行删除操作了
		// 执行删除操作，在哪执行，首先还是要定位
		// 定位到要删除的结点的前一个结点
		// 这里就要定义一个指针，因为要定位
		Node* tmp = node; // 想想这里为什么不用node->next,因为下标要从0开始走？----------
		// 我觉得原因就是：找到目标结点的前一个结点
		// 如果将tmp初始化为node->next,按照下面的方式找到的结点就是我们要删除的结点本身，而非它的前一个结点
		int i = 0; // 下标
		while (i < index) // 因为是要定位到前一个结点，所以i<index而非<=
		{
			i++;
			tmp = tmp->next;
		}

		// 定位完之后就要开始删除
		// 正常来讲，删除就是一句话 tmp->next = tmp->next->next;
		// 对于java而言是这样的，但是对于C语言来说，这样不行
		// 因为java里面有一个垃圾回收机制，能够帮我们自动去回收空间
		// C语言没有这个机制，就需要我们手动去释放
		// 怎么手动释放？
		// 先找一个指针指向被删除的结点
		Node* free_node = tmp->next;
		// 然后把指针指过去
		tmp->next = tmp->next->next;
		// 最后释放这个指针
		free(free_node);
	}
}